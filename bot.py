import asyncio
import time
from datetime import datetime, timedelta

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, CallbackQueryHandler

from config import BOT_TOKEN, OWNER_ID
from database import init_db, add_pending_payment_request, get_pending_payment_requests, mark_payment_processed, add_subscription, get_latest_subscription
from payments import get_crypto_price, verify_eth_payment, verify_sol_payment
from subscriptions import PLANS

# --- Telegram Bot Handlers ---
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the /start command."""
    await update.message.reply_text("üíé Welcome to the Crypto Subscription Bot! Use /plans to see available subscriptions.")

async def plans_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles the /plans command to show available subscription plans."""
    keyboard = []
    for k, v in PLANS.items():
        keyboard.append([InlineKeyboardButton(f"{k} - ${v['price']}", callback_data=f"plan:{k}")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "üíé *Choose a subscription plan:*", 
        reply_markup=reply_markup, 
        parse_mode="Markdown"
    )

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles button clicks (e.g., plan selection)."""
    query = update.callback_query
    await query.answer() # Acknowledge the callback query

    if query.data.startswith("plan:"):
        plan_name = query.data.split(":")[1]
        
        if plan_name not in PLANS:
            await query.message.reply_text("Invalid plan selected. Please try again.")
            return

        plan_details = PLANS[plan_name]
        usd_price = plan_details["price"]

        # Fetch current crypto prices
        eth_price = get_crypto_price("ETH")
        sol_price = get_crypto_price("SOL")

        if not eth_price or not sol_price:
            await query.message.reply_text("‚ùå Failed to fetch crypto prices. Please try again later.")
            return

        expected_eth_amount = round(usd_price / eth_price, 6)
        expected_sol_amount = round(usd_price / sol_price, 6)

        # Store pending payment requests in the database
        # NOTE: In a production bot, each payment request should ideally correspond to a unique, temporary wallet address
        # or a unique invoice ID generated by a payment gateway to ensure proper tracking and avoid sending to a shared address.
        # For simplicity here, we direct to the SAFE_ wallets, but this is a security risk for payment tracking in real apps.
        add_pending_payment_request(query.from_user.id, plan_name, "ETH", expected_eth_amount)
        add_pending_payment_request(query.from_user.id, plan_name, "SOL", expected_sol_amount)

        # Reply with payment instructions
        msg = (
            f"üí∞ *Payment Instructions for {plan_name} Plan*\n\n"
            f"Price: ${usd_price}\n\n"
            f"üîπ **Ethereum (ETH):**\n"
            f"Amount: `{expected_eth_amount}` ETH\n"
            f"Address: `{os.getenv('SAFE_ETH_WALLET')}`\n\n"
            f"üîπ **Solana (SOL):**\n"
            f"Amount: `{expected_sol_amount}` SOL\n"
            f"Address: `{os.getenv('SAFE_SOL_WALLET')}`\n\n"
            f"Once you send the payment, a background process will verify it automatically.\n"
            f"You will receive a confirmation message shortly after your payment is detected and confirmed on the blockchain."
            f"\n\n*Please ensure you send the exact crypto amount calculated.*"
        )
        await query.message.reply_text(msg, parse_mode="Markdown")

async def my_subscription_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Shows the user their current subscription status."""
    user_id = update.effective_user.id
    subscription = get_latest_subscription(user_id)

    if subscription:
        expires_dt = datetime.fromtimestamp(subscription["expires_ts"])
        time_left = expires_dt - datetime.now()
        await update.message.reply_text(
            f"üåü Your current plan: *{subscription['plan']}*\n"
            f"Expires on: `{expires_dt.strftime('%Y-%m-%d %H:%M:%S WAT')}`\n"
            f"Time remaining: `{time_left.days}` days, `{time_left.seconds // 3600}` hours",
            parse_mode="Markdown"
        )
    else:
        await update.message.reply_text("You don't have an active subscription. Use /plans to subscribe!")

# --- Background Task ---
async def check_payments_periodically(context: ContextTypes.DEFAULT_TYPE):
    """Background task to check for pending payments and update subscriptions."""
    pending_payments = get_pending_payment_requests()
    
    for payment in pending_payments:
        telegram_id = int(payment["telegram_id"])
        plan_name = payment["plan"]
        expected_amount = payment["expected_amount"]
        payment_chain = payment["chain"]
        
        is_paid = False
        tx_hash_found = None # Placeholder for a found transaction hash/signature

        # In a real bot, you'd have a mechanism to get the tx_hash/signature.
        # This could be from:
        # 1. User providing it (less reliable)
        # 2. Monitoring incoming transactions to the SAFE_WALLET (requires complex blockchain indexing)
        # For this example, let's assume we can somehow retrieve it.
        # For a full implementation, you would need to run blockchain scanners or use payment gateway webhooks.
        # For demonstration purposes, we will simulate finding a transaction.

        # Example: Mocking a transaction hash and verification
        # You'd replace this with actual blockchain monitoring and verification logic
        mock_tx_hash = "0xmocktransactionhash" + str(payment["id"]) # Just a placeholder
        
        if payment_chain == "ETH":
            # For demonstration, assume transaction is verified after some time
            # In real life: is_paid = await verify_eth_payment(actual_tx_hash, expected_amount)
            # You would need the actual_tx_hash for this to work.
            is_paid = True # Simulate success for demo
            tx_hash_found = mock_tx_hash 
        elif payment_chain == "SOL":
            # For demonstration, assume transaction is verified after some time
            # In real life: is_paid = await verify_sol_payment(actual_tx_signature, expected_amount)
            # You would need the actual_tx_signature for this to work.
            is_paid = True # Simulate success for demo
            tx_hash_found = mock_tx_hash

        if is_paid:
            mark_payment_processed(payment["id"], tx_hash=tx_hash_found)
            
            plan_details = PLANS[plan_name]
            duration_days = plan_details["duration"]
            
            start_ts = int(time.time())
            if duration_days is not None:
                expires_ts = start_ts + duration_days * 86400 # 86400 seconds in a day
            else: # Lifetime plan
                expires_ts = start_ts + 365 * 86400 * 100 # Effectively 100 years

            add_subscription(telegram_id, plan_name, start_ts, expires_ts)
            
            await context.bot.send_message(
                chat_id=telegram_id,
                text=f"‚úÖ Payment for *{plan_name}* confirmed! Your subscription is now active.",
                parse_mode="Markdown"
            )
            print(f"üí∞ Confirmed payment for user {telegram_id}, plan {plan_name}.")

        # Introduce a small delay to avoid rate limiting or excessive processing
        await asyncio.sleep(0.5)

# --- Main Application Setup ---
def main():
    """Starts the bot."""
    init_db() # Initialize the database

    application = ApplicationBuilder().token(BOT_TOKEN).build()
    
    # Register command handlers
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("plans", plans_command))
    application.add_handler(CommandHandler("mysubscription", my_subscription_command))
    
    # Register callback query handler for inline keyboard buttons
    application.add_handler(CallbackQueryHandler(button_handler))

    # Schedule the background payment checker job to run every 60 seconds
    application.job_queue.run_repeating(check_payments_periodically, interval=60)
    
    print("üöÄ Bot is polling...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()

